---
Author: sync
date: 2022-06-13 19:11 Monday
tag: Raft
---

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612112755.png)

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612112902.png)

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612113247.png)

# Raft  论文摘录： 5.2 领导人选举

Raft 使用一种<mark style="background: #ABF7F7A6;">心跳机制</mark> 来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。<u>一个服务器节点继续保持着跟随者状态只要他从领导人或者候选者处接收到有效的 RPCs</u>。领导者周期性的向所有跟随者发送<mark style="background: #ABF7F7A6;">心跳包</mark> （即不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<mark style="background: #ABF7F7A6;">「选举超时」</mark> ，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。

要开始一次选举过程，跟随者先要<mark style="background: #ABF7F7A6;">增加自己的当前任期号</mark> 并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导者，(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。

- (a) <mark style="background: #FFF3A3A6;">当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。</mark> 每一个服务器最多会对一个任期号投出一张选票，按照<mark style="background: #ABF7F7A6;">先来先服务的原则</mark> （注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。<u>然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</u>

- (b) <mark style="background: #FFF3A3A6;">在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项 RPC。</mark> **如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。** 如果此次 RPC 中的**任期号比自己小**，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。

- (c) <mark style="background: #FFF3A3A6;">第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时- 成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。</mark> 当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。

<mark style="background: #ABF7F7A6;">Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。</mark> 为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）**随机选择**。**这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时**；然后他赢得选举并在其他服务器超时之前发送心跳包。**同样的机制被用在选票瓜分的情况下。** <mark style="background: #ABF7F7A6;">每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，</mark> 然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。

领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。<mark style="background: #ABF7F7A6;">最终我们认为随机重试的方法是更加明显和易于理解的。</mark>
