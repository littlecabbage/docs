> created: 2022-09-17T17:15:34
> tags: [gil python]
> source: [原文地址](https://blog.csdn.net/fanfangyu/article/details/120920545)
> author:

---

# Python 中的 GIL(全局解释器锁)详解及解决 GIL 的几种方案_菜鸟教程*…*的博客-CSDN 博客_gil python

先看一道 GIL 面试题：
描述 Python GIL 的概念， 以及它对 python [多线程](https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020) 的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。
**GIL：又叫全局解释器锁，每个线程在执行的过程中都需要先获取 GIL，保证同一时刻只有一个线程在运行，目的是解决多线程同时竞争程序中的全局变量而出现的线程安全问题。** 它并不是 python 语言的特性，仅仅是由于历史的原因在 CPython 解释器中难以移除，因为 python 语言运行环境大部分默认在 CPython 解释器中。

## 1. 两个例子分析 GIL 的影响
通过一个案例了解单线程和多线程的 cpu 占用率：
打开 Ubuntu 终端命令：输入 htop，回车，红色箭头指向的 2 代表此时我的虚拟机中 CPU 有两个核心数

![](https://img-blog.csdnimg.cn/20190419132237727.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODA4MTU0,size_16,color_FFFFFF,t_70)

 下面通过一个案例了解单线程死循环和多线程死循环的 CPU 占用率：

**单线程死循环.py：**

```python
while True:
    pass
```

运行该程序，出现以下界面：

![](https://img-blog.csdnimg.cn/20190419133058821.gif)

 此时新开一个窗口，输入 htop，查看 CPU 占用率，其中一个 CPU 占用率几乎为 100%：

![](https://img-blog.csdnimg.cn/20190419133305269.gif)

 **两个线程死循环.py**

```python
#coding=utf-8
import threading
 
#子线程死循环
def test():
    while True:
        pass
 
t1=threading.Thread(target=test)
t1.start()
 
#主线程死循环,
while True:
    pass
```

 此时新开一个终端，输入 htop 查看 CPU 占用率，可以看到两个 CPU 任何一个并没有全部占满，而是交替执行的：

![](https://img-blog.csdnimg.cn/20190419134249403.gif)

 这也就验证了**多线程下每个线程在执行的过程中都需要先获取 GIL，保证同一时刻只有一个线程在运行。**

由于 GIL 的存在，即使是多线程，事实上同一时刻只能保证一个线程在运行，既然这样多线程的运行效率不就和单线程一样了吗，那为什么还要使用多线程呢？

由于以前的电脑基本都是单核 CPU，多线程和单线程几乎看不出差别，可是由于计算机的迅速发展，现在的电脑几乎都是多核 CPU 了，最少也是两个核心数的，这时差别就出来了：**通过之前的案例我们已经知道，即使在多核 CPU 中，多线程同一时刻也只有一个线程在运行，这样不仅不能利用多核 CPU 的优势，反而由于每个线程在多个 CPU 上是交替执行的，导致在不同 CPU 上切换时造成资源的浪费，反而会更慢。即原因是一个进程只存在一把 gil 锁，当在执行多个线程时，内部会争抢 gil 锁，这会造成当某一个线程没有抢到锁的时候会让 cpu 等待，进而不能合理利用多核 cpu 资源。**

例如在使用多线程抓取网页内容时，遇到 IO 阻塞时，正在执行的线程会暂时释放 GIL 锁，这时其它线程会利用这个空隙时间，执行自己的代码，因此多线程抓取比单线程抓取性能要好。

## 2. 计算密集型与 IO 密集型

说到在这里要先介绍两个概念：**计算密集型和 IO 密集型**

**计算密集型：**要进行大量的数值计算，例如进行上亿的数字计算、计算圆周率、对视频进行高清解码等等。这种计算密集型任务虽然也可以用多任务完成，但是花费的主要时间在任务切换的时间，此时 CPU 执行任务的效率比较低。

**IO 密集型：**涉及到网络请求(time.sleep())、磁盘 IO 的任务都是 IO 密集型任务，这类任务的特点是 CPU 消耗很少，任务的大部分时间都在等待 IO 操作完成（因为 IO 的速度远远低于 CPU 和内存的速度）。对于 IO 密集型任务，任务越多，CPU 效率越高，但也有一个限度。

## 3. 解决 GIL 问题的方案

**解决 GIL 问题的方案：**
1. 使用其它语言，例如 C,Java
2. 使用其它解释器，如 java 的解释器 jython
3. 使用多进程

**线程释放 GIL 锁的情况：
1.在 IO 操作等可能会引起阻塞的 system call 之前,可以暂时释放 GIL,但在执行完毕后,必须重新获取 GIL。**
**2.Python 3.x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）或 Python 2.x，tickets 计数达到 100。**

**GIL 面试题参考答案：**
1. Python 语言和 GIL 没有什么关系。仅仅是由于历史原因在 Cpython 虚拟机(解释器)，难以移除 GIL。
2. GIL：全局解释器锁。每个线程在执行的过程都需要先获取 GIL，保证同一时刻只有一个线程可以执行代码。
3. 线程释放 GIL 锁的情况： 在 IO 操作等可能会引起阻塞的 system call 之前,可以暂时释放 GIL,但在执行完毕后,必须重新获取 GIL Python 3.x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）或 Python 2.x，tickets 计数达到 100。
4. Python 使用多进程是可以利用多核的 CPU 资源的。
5. 多线程爬取比单线程性能有提升，因为遇到 IO 阻塞会自动释放 GIL 锁。
