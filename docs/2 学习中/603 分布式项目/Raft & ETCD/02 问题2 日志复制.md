---
Author: sync
date: 2022-06-13 19:11 Monday
tag: Raft
---

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612113841.png)

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612113855.png)

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612114125.png)

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612114552.png)
优化：

- 由 follower 发送自己最后一个日志号
- Leader 间隔发送日志号， 采用二分查找

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612114929.png)

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612115234.png)

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220612115330.png)

# Raft 论文摘录： 5.3 日志复制

<mark style="background: #ABF7F7A6;">一旦一个领导人被选举出来，他就开始为客户端提供服务。</mark> <u>客户端</u> 的每一个请求都包含<mark style="background: #FFF3A3A6;">一条被复制状态机执行的指令</mark> 。<u>领导人</u> 把这条指令作为<mark style="background: #FFF3A3A6;">一条新的日志条目</mark> 附加到日志中去，然后**并行**的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。<mark style="background: #ADCCFFA6;">当这条日志条目被安全的复制</mark> （下面会介绍），<u>领导人</u> 会应用这条日志条目到它的状态机中然后把执行的结果返回给 <u>客户端</u>。<mark style="background: #ADCCFFA6;">如果跟随者崩溃或者运行缓慢，再或者网络丢包，</mark> <u>领导人</u> 会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的 <u>跟随者</u> 都最终存储了所有的日志条目。

![图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。](FigureBed%20🌄/Pasted/Pasted%20image%2020220613100345.png)

> 图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。

日志以图 6 展示的方式组织。<mark style="background: #ABF7F7A6;">每一个日志条目存储</mark> <mark style="background: #FFF3A3A6;">一条状态机指令</mark> <mark style="background: #ABF7F7A6;">和</mark> <mark style="background: #FFF3A3A6;">从领导人收到这条指令时的任期号</mark> 。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。<mark style="background: #ABF7F7A6;">每一条日志条目同时也都有</mark> <mark style="background: #FFF3A3A6;">一个整数索引值</mark> <mark style="background: #ABF7F7A6;">来表明它在日志中的位置。</mark>

<mark style="background: #ABF7F7A6;">领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为</mark> <font color = '#ABF7F7A6'>「已提交」</font>。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到 **大多数** 的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。**同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。** 5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。

<mark style="background: #ABF7F7A6;">我们设计了 Raft 的日志机制来维护一个不同服务器的日志之间的高层次的一致性。</mark> 这么做不仅简化了系统的行为也使得更加可预计，同时他也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些同时也组成了图 3 中的日志匹配特性：

- 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。
- 如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。

<mark style="background: #ABF7F7A6;">第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。</mark>

<mark style="background: #ABF7F7A6;">第二个特性由附加日志 RPC 的一个简单的一致性检查所保证</mark> 。在发送附加日志 RPC 的时候，领导人会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个<mark style="background: #ABF7F7A6;">归纳步骤</mark> ：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查保护了日志匹配特性当日志扩展的时候。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。

<mark style="background: #ABF7F7A6;">在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败</mark> 。然而，<mark style="background: #FF5582A6;">领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。</mark> 这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同的方式。跟随者可能会丢失一些在新的领导人中有的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220613103427.png)

> 图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。
> 跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。

例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。

在 Raft 算法中，<mark style="background: #ABF7F7A6;">领导人处理不一致是通过强制跟随者直接复制自己的日志来解决。</mark> 这意味着在跟随者中的冲突的日志条目会被领导人的日志<mark style="background: #ABF7F7A6;">覆盖</mark> 。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。

<mark style="background: #ABF7F7A6;"> 要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给跟随者</mark> 。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 **「nextIndex」**，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的index加1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。

如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来<mark style="background: #ABF7F7A6;">优化</mark> 。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息，领导人可以减小 nextIndex 越过所有那个任期冲突的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，<mark style="background: #ABF7F7A6;">因为失败是很少发生的并且也不大可能会有这么多不一致的日志</mark> 。

通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。

日志复制机制展示出了第 2 节中形容的一致性特性：

- Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；
- 在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；
- 并且单个的缓慢的跟随者不会影响整体的性能。
