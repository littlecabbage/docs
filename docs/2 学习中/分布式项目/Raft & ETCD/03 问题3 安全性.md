---
Author: sync
date: 2022-06-13 19:11 Monday
tag: 分布式/Raft
---

# Raft 论文摘录： 5.4 安全性

前面的章节里描述了 Raft 算法是如何选举和复制日志的。<mark style="background: #ABF7F7A6;">然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。</mark> 例如，一<u>个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；</u>因此，不同的状态机可能会执行不同的指令序列。

这一节通过在领导选举的时候增加一些 **限制** 来完善 Raft 算法。<mark style="background: #ABF7F7A6;">这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。</mark> 增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于领导人完整特性的简要证明，并且说明领导人是如何领导复制状态机的做出正确行为的。

## 5.4.1 选举限制

<mark style="background: #ABF7F7A6;">在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。</mark> 在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导者。**这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，**<u> 要么是在选举阶段</u>，<u>要么在之后很快进行</u>。<mark style="background: #FFF3A3A6;">不幸的是，这种方法会导致相当大的额外的机制和复杂性</mark> 。Raft 使用了一种更加简单的方法，它可以保证所有之前的任期号中已经提交的日志条目<mark style="background: #ABF7F7A6;">在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人。</mark> **这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。**

<mark style="background: #ABF7F7A6;">Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。</mark> 候选人为了赢得选举必须联系集群中的大部分节点，<mark style="background: #D2B3FFA6;">这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。</mark> <mark style="background: #D2B3FFA6;">如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。</mark> <mark style="background: #ABF7F7A6;">请求投票 RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。 </mark>

Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。<mark style="background: #ABF7F7A6;">如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</mark> 

## 5.4.2 提交之前任期内的日志条目

<mark style="background: #ABF7F7A6;">如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。</mark> 如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。<mark style="background: #FF5582A6;">然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。</mark> 图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220613111217.png)

**图 8：**<mark style="background: #ABF7F7A6;"> 如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。</mark>

- 在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。
- 在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。
- 然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。
- 如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。
- 反之，<mark style="background: #FF5582A6;">如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上</mark> ，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。

<mark style="background: #ABF7F7A6;">为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。</mark> 只<mark style="background: #FF5582A6;">有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。</mark> 在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。

当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。

## 5.4.3 安全性论证

# 5.5 跟随者和候选人崩溃

到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。<mark style="background: #ABF7F7A6;">如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单的通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。</mark> 如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。

# 5.6 时间可用性

<mark style="background: #ABF7F7A6;">Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。</mark> <mark style="background: #FFF3A3A6;">但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。 </mark>

领导人选举是 Raft 中对时间要求最为关键的方面。<mark style="background: #ABF7F7A6;">Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</mark>

![](FigureBed%20🌄/Pasted/Pasted%20image%2020220613112550.png)

在这个不等式中，

- **广播时间** 指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；
- **选举超时时间** 就是在 5.2 节中介绍的选举的超时时间限制；
- 然后 **平均故障间隔时间** 就是对于一台服务器而言，两次故障之间的平均时间。

广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的<mark style="background: #FFF3A3A6;">心跳消息</mark> 来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。

广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。
